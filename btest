#! /usr/bin/env python
#
# Main test driver.

import os
import os.path
import sys
import shutil
import fnmatch
import optparse
import re
import tempfile
import subprocess
import copy
import glob
import fnmatch
import ConfigParser
import time
import multiprocessing
import multiprocessing.managers
import multiprocessing.sharedctypes

VERSION = "0.22-27" # Automatically filled in.

Name ="btest"
ConfigDefault = "btest.cfg"
Config = None

RE_INPUT = re.compile("%INPUT")
RE_DIR = re.compile("%DIR")
RE_ENV = re.compile("\$\{(\w+)\}")
RE_START_NEXT_TEST = re.compile("@TEST-START-NEXT")
RE_START_FILE = re.compile("@TEST-START-FILE +([^\n ]*)")
RE_END_FILE = re.compile("@TEST-END-FILE")

# Commands as tuple (tag, regexp, more-than-one-is-ok, optional, group-main, group-add)
RE_EXEC     = ("exec",     re.compile("@TEST-EXEC(-FAIL)?: *(.*)"), True, False, 2, 1)
RE_REQUIRES = ("requires", re.compile("@TEST-REQUIRES: *(.*)"), True, True, 1, -1)
RE_GROUP    = ("group",    re.compile("@TEST-GROUP: *(.*)"), False, True, 1, -1)

Commands = (RE_EXEC, RE_REQUIRES, RE_GROUP)

def output(msg, nl=True, file=None):
    if not file:
        file = sys.stderr

    if nl:
        print >>file, msg
    else:
        print >>file, msg,

def error(msg):
    print >>sys.stderr, msg
    sys.exit(1)

def mkdir(dir):
    if not os.path.exists(dir):
        try:
            os.mkdir(dir)
        except OSError, e:
            error("cannot create directory %s: %s" % (dir, e))

    else:
        if not os.path.isdir(dir):
            error("path %s exists but is not a directory" % dir)

def getOption(key, default):
    try:
        return Config.get("btest", key)
    except ConfigParser.NoSectionError:
        return default

reBackticks = re.compile(r"`(([^`]|\`)*)`")

# We monkey-patch the OptionParser to expand backticks.
def cpExpandBackticks(self, section, option, rawval, vars):
    def _exec(m):
        cmd = m.group(1)
        if not cmd:
            return ""

        try:
            return subprocess.Popen(cmd.split(), stdout=subprocess.PIPE).communicate()[0].strip()
        except OSError, e:
            error("cannot execute '%s': %s" % (cmd, e))

    value = cpOriginalInterpolate(self, section, option, rawval, vars)
    value = reBackticks.sub(_exec, value)

    return value

cpOriginalInterpolate = ConfigParser.ConfigParser._interpolate
ConfigParser.ConfigParser._interpolate = cpExpandBackticks

# Main class distributing the work across threads.
class TestManager(multiprocessing.managers.SyncManager):
    def __init__(self):
        super(TestManager, self).__init__()

    def run(self, tests, groups):
        self.start()

        self._lock = self.Lock()
        self._succeeded = multiprocessing.sharedctypes.RawValue('i', 0)
        self._failed = multiprocessing.sharedctypes.RawValue('i', 0)
        self._skipped = multiprocessing.sharedctypes.RawValue('i', 0)
        self._tests = self.list(tests)

        num_threads = Options.threads

        if num_threads:
            threads = []

            for i in range(num_threads):
                t = multiprocessing.Process(name="#%d" % (i+1), target=lambda : self.threadRun(groups[i::num_threads]))
                t.start()
                threads += [t]

            for t in threads:
                t.join()

        else:
            # No threads, just run all directly.
            self.threadRun(groups)

        return (self._succeeded.value, self._failed.value, self._skipped.value)

    def threadRun(self, groups):
        while True:
            tests = self.nextTests(groups)
            if not tests:
                # No more work for us.
                return

            for t in tests:
                t.run(self)
                t.replayOutput(self)

    def nextTests(self, groups):
        with self._lock:
            for i in range(len(self._tests)):
                t = self._tests[i]
                if t and (not t.group or t.group in groups):
                    del self._tests[i]

                    tests = [t]

                    if Filters:
                        filtered_test = copy.deepcopy(test)
                        filtered_test.setFilter(Options.filter)
                        tests += [filtered_test]
                        self._pending.release()

                    return tests

        # No more tests for this group.
        return None

    def lock(self):
        return self._lock

    def testSucceeded(self):
        with self._lock:
            self._succeeded.value += 1

    def testFailed(self):
        with self._lock:
            self._failed.value += 1

    def testSkipped(self):
        with self._lock:
            self._skipped.value += 1

# One test.
class Test(object):
    def __init__(self, file):
        self.file = file
        self.dir = os.path.abspath(os.path.dirname(file))
        self.name = None
        self.number = 1
        self.group = None
        self.cmdlines = []
        self.tmpdir = None
        self.diag = None
        self.baseline = None
        self.filter = None
        self.files = []
        self.requires = []
        self.buffered_output = []

    def setFilter(self, filter):
        self.filter = filter

    def output(self, msg, nl=True, file=None):
        if not Options.threads:
            output(msg, nl, file)
            return

        self.buffered_output += [(msg, nl, file)]

    def error(self, msg):
        error(msg)

    def replayOutput(self, mgr):
        if not Options.threads:
            return

        with mgr.lock():
            for (msg, nl, file) in self.buffered_output:
                output(msg, nl, file)

        # Parse the test's content.
    def parse(self, content):
        cmds = {}
        for line in content:

            if line.find("@TEST-IGNORE") >= 0:
                # Ignore this file.
                return False

            for (tag, regexp, multiple, optional, group1, group2) in Commands:
                m = regexp.search(line)

                if m:
                    value = m.group(group1)

                    if group2 >= 0:
                        value = (value, m.group(group2))

                    if not multiple:
                        if tag in cmds:
                            self.error("%s: %d defined multiple times." % (test, tag))

                        cmds[tag] = value

                    else:
                        try:
                            cmds[tag] += [value]
                        except KeyError:
                            cmds[tag] = [value]

        # Make sure all non-optional commands are there.
        for (tag, regexp, multiple, optional, group1, group2) in Commands:
            if not optional and not tag in cmds:
                self.error("%s: mandatory %s command not found." % (self.file, tag))

        (name, ext) = os.path.splitext(self.file)

        self.name = name.replace("/", ".")
        while self.name.startswith("."):
            self.name = self.name[1:]

        self.content = content
        self.cmdlines = [(cmd.strip(), success!="-FAIL") for (cmd, success) in cmds["exec"]]

        if "group" in cmds:
            self.group = cmds["group"]

        if "requires" in cmds:
            self.requires = [cmd.strip() for cmd in cmds["requires"]]

        if Substitutions:
            for (key, val) in Substitutions.items():
                self.cmdlines = [(re.sub("\\b" + re.escape(key) + "\\b", val, cmd[0]), cmd[1]) for cmd in self.cmdlines]

        return True

    # Copies all control information over to a new Test but replaces test
    # content with a new one.
    def clone(self, content):
        clone = Test("")
        clone.file = self.file
        clone.number = self.number + 1
        clone.name = self.name
        clone.group = self.group
        clone.cmdlines = self.cmdlines

        clone.content = content

        return clone

    def run(self, mgr):
        if self.number > 1:
            self.name = "%s-%d" % (self.name, self.number)

        if not self.filter:
            name = self.name
        else:
            name = "%s (%s)" % (self.name, self.filter)

        if Options.threads:
            name = "[%s] %s" % (multiprocessing.current_process().name, name)

        if Options.verbose or not Options.brief:
            self.output("%s ..." % name, nl=Options.verbose)

        self.tmpdir = os.path.abspath(os.path.join(TmpDir, self.name))
        self.diag = os.path.join(self.tmpdir, ".diag")
        self.baseline = os.path.abspath(os.path.join(BaselineDir, self.name))
        self.diagmsgs = []

        self.rmTmp()
        mkdir(self.baseline)
        mkdir(self.tmpdir)

        for (fname, lines) in self.files:
            fname = os.path.join(self.tmpdir, fname)

            subdir = os.path.dirname(fname)
            if subdir != "":
                mkdir(subdir)
            try:
                ffile = open(fname, "w")
            except IOError, e:
                self.error("cannot write test's additional file '%s'" % fname)

            for line in lines:
                print >>ffile, line,

            ffile.close()

        self.localfile = os.path.join(self.tmpdir, os.path.basename(self.file))

        content = open(self.localfile, "w")
        for line in self.content:
            print >>content, line,
        content.close()

        self.log = open(os.path.join(self.tmpdir, ".log"), "w")
        self.stdout = open(os.path.join(self.tmpdir, ".stdout"), "w")
        self.stderr = open(os.path.join(self.tmpdir, ".stderr"), "w")

        for cmd in self.requires:
            (success, rc) = self.execute((cmd, True), apply_filter=(self.filter != None))

            if not success:
                mgr.testSkipped()

                if Options.verbose:
                    self.output("... %s not available, skipped" % name)

                else:
                    if not Options.brief:
                        self.output("not available, skipped")

                if Options.diagfile:
                    self.output("%s ... not available, skipped" % name, True, Options.diagfile)

                self.finish()
                return

        failures = 0

        for cmd in self.cmdlines:

            (success, rc) = self.execute(cmd, apply_filter=(self.filter != None))

            if not success:
                failures += 1

                if failures == 1:
                    mgr.testFailed()

                    if Options.verbose:
                        self.output("... %s failed" % name)

                    else:
                        if Options.brief:
                            self.output("%s ..." % name, nl=False)

                        self.output(" failed")

                    if Options.diagfile:
                        self.output("%s ... failed" % name, True, Options.diagfile)

                if Options.diag or Options.diagall:
                    self.showDiag()

                if Options.diagfile:
                    self.showDiag(Options.diagfile)

                if rc == 200:
                    # Abort all tests.
                    sys.exit(1)

                if rc != 100:
                    break

        if failures == 0:
            mgr.testSucceeded()

            if Options.verbose:
                    self.output("... %s ok" % name)
            else:
                if not Options.brief:
                    self.output("ok")

            if Options.diagall:
                self.showDiag()

            if not Options.tmps:
                self.rmTmp()

        self.finish()

    def finish(self):
        try:
            # Try removing the baseline directory. If it works, it's empty, i.e., no baseline was created.
            os.rmdir(self.baseline)
        except OSError, e:
            pass

        self.log.close()
        self.stdout.close()
        self.stderr.close()

    def execute(self, cmd, apply_filter=False):
        (cmdline, expect_success) = cmd

        # See if we need to apply a filter.
        filter_cmd = None

        if apply_filter:
            try:
                (path, executable) = os.path.split(cmdline.split()[0])
                filter_cmd = Filters[executable]
            except LookupError:
                pass

        if not filter_cmd or not expect_success: # Do not apply filter if we expect failure.
            localfile = self.localfile

        else:
            # This is not quite correct as it does not necessarily need to be
            # the %INPUT file which we are filtering ...
            filtered = os.path.join(self.tmpdir, "filtered-%s" % os.path.basename(self.localfile))
            (success, rc) = self.execute(("%s %s %s" % (filter_cmd, self.localfile, filtered), True), apply_filter=False)
            if not success:
                return (False, rc)

            (success, rc) = self.execute(("mv %s %s" % (filtered, self.localfile), True), apply_filter=False)
            if not success:
                return (False, rc)

            localfile = self.localfile

        if Options.verbose:
            self.output("  > %s" % cmdline)

        # Replace special names.
        cmdline = RE_INPUT.sub(localfile, cmdline)
        cmdline = RE_DIR.sub(self.dir, cmdline)

        # Replace environment variables.
        def replace_with_env(m):
            try:
                return os.environ[m.group(1)]
            except KeyError:
                return ""

        cmdline = RE_ENV.sub(replace_with_env, cmdline)

        print >>self.log, cmdline, "(expect %s)" % ("success" if expect_success else "failure")

        env = self.prepareEnv()

        try:
            subprocess.check_call(cmdline, cwd=self.tmpdir, shell=True, env=env, stderr=self.stderr, stdout=self.stdout)
        except subprocess.CalledProcessError, e:
            if expect_success:
                self.diagmsgs += ["'%s' failed unexpectedly (exit code %s)" % (cmdline, e.returncode)]
                return (False, e.returncode)

            else:
                return (True, e.returncode)

        if not expect_success:
            self.diagmsgs += ["'%s' succeeded unexpectedly (exit code 0)" % cmdline]
            return (False, 0)

        return (True, 0)

    def rmTmp(self):
        try:
            if os.path.isfile(self.tmpdir):
                os.remove(self.tmpdir)

            if os.path.isdir(self.tmpdir):
                subprocess.call("rm -rf %s 2>/dev/null" % self.tmpdir, shell=True)

        except OSError, e:
            self.error("cannot remove tmp directory %s: %s" % (self.tmpdir, e))

    # Prepares the environment for the child processes.
    def prepareEnv(self):
        env = copy.deepcopy(os.environ)
        env["TEST_BASELINE"] = self.baseline
        env["TEST_DIAGNOSTICS"] = self.diag
        env["TEST_MODE"] = Options.mode.upper()
        env["TEST_NAME"] = self.name
        return env

    def addFiles(self, files):
        # files is a list of tuple (fname, lines).
        self.files = files

    def showDiag(self, file=None):
        for line in self.diagmsgs:
            self.output("  % " + line, file=file)

        for f in (self.diag, ".stderr"):
            if not f:
                continue

            if os.path.isfile(f):
                self.output("  % cat " + os.path.basename(f), file=file)
                for line in open(f):
                    self.output("  " + line.strip(), file=file)
                self.output("", file=file)

        if Options.wait and not file:
            self.output("<Enter> ...")
            try:
                sys.stdin.readline()
            except KeyboardInterrupt:
                sys.exit(1)

# Walk the given directory and return all test files.
def findTests(paths):
    tests = []

    ignore_files = getOption("IgnoreFiles", "").split()
    ignore_dirs = getOption("IgnoreDirs", "").split()

    for path in paths:
        if os.path.isfile(path):
            tests += readTestFile(path)

        elif os.path.isdir(path):
            for (dirpath, dirnames, filenames) in os.walk(path):
                for file in filenames:
                    for glob in ignore_files:
                        if fnmatch.fnmatch(file, glob):
                            break
                    else:
                        tests += readTestFile(os.path.join(dirpath, file))

                # Don't recurse into these.
                for skip in ignore_dirs:
                    if skip in dirnames:
                        dirnames.remove(skip)

        else:
            # See if we have a test named like this in our configured set.
            for t in Config.configured_tests:
                if t and path == t.name:
                    tests += [t]
                    break

            else:
                error("cannot read %s" % path)

    return tests

# Read the given test file and instantiate one or more tests from it.
def readTestFile(filename):

    def newTest(content, previous):
        if not previous:
            t = Test(filename)
            if t.parse(content):
                return t
            else:
                return None
        else:
            return previous.clone(content)

    try:
        input = open(filename)
    except IOError, e:
        error("cannot read test file: %s" % e)

    tests = []
    files = []

    content = []
    previous = None
    file = (None, [])

    state = "test"

    for line in input:

        if state == "test":
            m = RE_START_FILE.search(line)
            if m:
                state = "file"
                file = (m.group(1), [])
                continue

            m = RE_END_FILE.search(line)
            if m:
                error("unexpected @test-end-file")

            m = RE_START_NEXT_TEST.search(line)
            if not m:
                content += [line]
                continue

            t = newTest(content, previous)
            if not t:
                return []

            tests += [t]

            previous = t
            content = []

        elif state == "file":
            m = RE_END_FILE.search(line)
            if m:
                state = "test"
                files += [file]
                file = (None, [])
                continue

            file = (file[0], file[1] + [line])

        else:
            error("internal: unknown state %s" % state)

    if state == "file":
        files += [file]

    tests += [newTest(content, previous)]

    input.close()

    for t in tests:
        if t:
            t.addFiles(files)

    return tests

### Main

optparser = optparse.OptionParser(usage="%prog [options] <directorys>", version=VERSION)
optparser.add_option("-U", "--update-baseline", action="store_const", dest="mode", const="UPDATE",
                     help="create a new baseline from the tests' output")
optparser.add_option("-u", "--update-interactive", action="store_const", dest="mode", const="UPDATE_INTERACTIVE",
                     help="interactively asks whether to update baseline for a failed test")
optparser.add_option("-d", "--diagnostics", action="store_true", dest="diag", default=False,
                     help="show diagnostic output for failed tests")
optparser.add_option("-D", "--diagnostics-all", action="store_true", dest="diagall", default=False,
                     help="show diagnostic output for ALL tests")
optparser.add_option("-f", "--file-diagnostics", action="store", type="string", dest="diagfile", default="",
                     help="write diagnostic output for failed tests into file; if files exists, output is appended")
optparser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False,
                     help="show commands as they are executed")
optparser.add_option("-w", "--wait", action="store_true", dest="wait", default=False,
                     help="wait for <enter> after each failed (with -d) or all (with -D) tests")
optparser.add_option("-b", "--brief", action="store_true", dest="brief", default=False,
                     help="outputs only failed tests")
optparser.add_option("-c", "--config", action="store", type="string", dest="config", default=ConfigDefault,
                     help="configuration file")
optparser.add_option("-F", "--filter", action="store", type="string", dest="filter", default=None,
                     help="active filter in given config file section")
optparser.add_option("-t", "--tmp-keep", action="store_true", dest="tmps", default=False,
                     help="do not delete tmp files created for running tests")
optparser.add_option("-S", "--subst", action="store", type="string", dest="subst", default=None,
                     help="active substitution in given config file section")
optparser.add_option("-j", "--jobs", action="store", type="int", dest="threads", default=0,
                     help="number of threads to run tests in simultaniously; 0 disables threading")
optparser.add_option("-g", "--group", action="store", type="string", dest="group", default=None,
                     help="execute only test of given group, or '-' for those without any group")

optparser.set_defaults(mode="TEST")
(Options, args) = optparser.parse_args()

(basedir, fname) = os.path.split(Options.config)

if not basedir:
    basedir = "."

os.chdir(basedir)

defaults=os.environ
defaults["testbase"] = os.path.abspath(basedir)
defaults["default_path"] = os.environ["PATH"]
Config = ConfigParser.ConfigParser(defaults)
Config.read(Options.config)

if Options.diagfile:
    try:
        Options.diagfile = open(Options.diagfile, "a")
    except IOError, e:
        print >>sys.stderr, "cannot open %s: %s" (Options.diagfile, e)

if Config.has_section("environment"):
    for (name, value) in Config.items("environment"):
        os.environ[name.upper()] = value

Filters = {}
if Options.filter:
    sec = "filters-%s" % Options.filter
    if not Config.has_section(sec):
        error("configuration file has no section '%s'" % sec)

    for (name, value) in Config.items(sec):
        Filters[name] = value

Substitutions = {}
if Options.subst:
    sec = "subst-%s" % Options.subst
    if not Config.has_section(sec):
        error("configuration file has no section '%s'" % sec)

    for (name, value) in Config.items(sec):
        Substitutions[name] = value

# Add the directory where this executable is located to PATH.
addpath = os.path.abspath(os.path.dirname(sys.argv[0]))
oldpath = os.environ["PATH"]
os.environ["PATH"] = "%s:%s" % (addpath, oldpath) if oldpath else addpath

Config.configured_tests = []
testdirs = getOption("TestDirs", None).split()
if testdirs:
    Config.configured_tests = findTests(testdirs)

if args:
    tests = findTests(args)
else:
    tests = Config.configured_tests

if Options.group:
    def rightGroup(t):
        if Options.group == t.group:
            return True

        if Options.group == "-" and not t.group:
            return True

        return False

    tests = [t for t in tests if rightGroup(t)]

if not tests:
    output("no tests given")
    sys.exit(0)

TmpDir = os.path.abspath(getOption("TmpDir", os.path.join(defaults["testbase"], ".tmp")))
BaselineDir = os.path.abspath(getOption("BaselineDir", os.path.join(defaults["testbase"], "Baseline")))
mkdir(BaselineDir)
mkdir(TmpDir)

groups = set([t.group for t in tests if t.group])
(succeeded, failed, skipped) = TestManager().run(copy.deepcopy(tests), list(groups))
total = succeeded + failed + skipped

if total != len(tests):
    output("internal btest error: not all tests processed (%d vs %d)" % (total, len(tests)))
    sys.exit(1)

if failed > 0:
    skipped = (", %d skipped" % skipped) if skipped > 0 else ""
    output("%d of %d test%s failed%s" % (failed, total, "s" if total > 1 else "", skipped))
    sys.exit(1)

else:
    output("all %d tests successful" % total)
    sys.exit(0)

